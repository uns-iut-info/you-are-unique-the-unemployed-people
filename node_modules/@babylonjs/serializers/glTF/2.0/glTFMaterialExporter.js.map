{"version":3,"file":"glTFMaterialExporter.js","sourceRoot":"","sources":["../../../../../../lts/serializers/generated/glTF/2.0/glTFMaterialExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    ITextureInfo,\r\n    IMaterial,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterialOcclusionTextureInfo,\r\n    ISampler,\r\n    ITexture,\r\n    IImage,\r\n    IMaterialExtension,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\ndeclare type Material = import(\"core/Materials/material\").Material;\r\ndeclare type StandardMaterial = import(\"core/Materials/standardMaterial\").StandardMaterial;\r\ndeclare type PBRBaseMaterial = import(\"core/Materials/PBR/pbrBaseMaterial\").PBRBaseMaterial;\r\ndeclare type PBRMaterial = import(\"core/Materials/PBR/pbrMaterial\").PBRMaterial;\r\ndeclare type PBRMetallicRoughnessMaterial = import(\"core/Materials/PBR/pbrMetallicRoughnessMaterial\").PBRMetallicRoughnessMaterial;\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n     */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n     */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @hidden\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n     */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metallness of the material\r\n     */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n     */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture as a base64 string\r\n     */\r\n    metallicRoughnessTextureBase64?: Nullable<string>;\r\n    /**\r\n     * The base color texture as a base64 string\r\n     */\r\n    baseColorTextureBase64?: Nullable<string>;\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @hidden\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static _FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) && Scalar.WithinEpsilon(color1.g, color2.g, epsilon) && Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param exportMaterials\r\n     * @param mimeType texture mime type\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(exportMaterials: Set<Material>, mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        const promises: Promise<IMaterial>[] = [];\r\n        exportMaterials.forEach((material) => {\r\n            if (material.getClassName() === \"StandardMaterial\") {\r\n                promises.push(this._convertStandardMaterialAsync(material as StandardMaterial, mimeType, hasTextureCoords));\r\n            } else if (material.getClassName().indexOf(\"PBR\") !== -1) {\r\n                promises.push(this._convertPBRMaterialAsync(material as PBRMaterial, mimeType, hasTextureCoords));\r\n            } else {\r\n                Tools.Warn(`Unsupported material type: ${material.name}`);\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        const newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (material.extensions) {\r\n            for (const extension in material.extensions) {\r\n                const extensionObject = material.extensions[extension];\r\n                if (extensionObject as IMaterialExtension) {\r\n                    return extensionObject.hasTextures?.();\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        if (babylonTexture) {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        // Defines a cubic bezier curve where x is specular power and y is roughness\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function solveForRoughness(specularPower: number): number {\r\n            // Given P0.x = 0, P1.x = 0, P2.x = 0\r\n            //   x = t * t * t * P3.x\r\n            //   t = (x / P3.x)^(1/3)\r\n            const t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace().scale(0.5);\r\n        const opacity = babylonStandardMaterial.alpha;\r\n        const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = (diffuse * oneMinusSpecularStrength) / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        } else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const glTFPbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const glTFMaterial: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.bumpTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (babylonStandardMaterial.bumpTexture != null && babylonStandardMaterial.bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = babylonStandardMaterial.bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                glTFMaterial.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((glTFEmissiveTexture) => {\r\n                        if (glTFEmissiveTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFEmissiveTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                            };\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            occlusionTexture.strength = 1.0;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter._FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            glTFMaterial.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonStandardMaterial);\r\n\r\n        materials.push(glTFMaterial);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (const texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                const extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private _createBase64FromCanvasAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<string> {\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        return new Promise<string>(async (resolve) => {\r\n            const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n            const hostingScene = this._exporter._babylonScene;\r\n            const engine = hostingScene.getEngine();\r\n\r\n            // Create a temporary texture with the texture buffer data\r\n            const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n            await TextureTools.ApplyPostProcess(\"pass\", tempTexture, hostingScene, textureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n            const data = await engine._readTexturePixels(tempTexture, width, height);\r\n\r\n            const base64: string = await (Tools.DumpDataAsync(width, height, data, mimeType, undefined, true, false) as Promise<string>);\r\n\r\n            resolve(base64);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        } else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        } else {\r\n            throw new Error(\"Unsupported pixel format!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: _IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject(\"_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace().multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace()\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace();\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /=\r\n                        metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                const promise = this._createBase64FromCanvasAsync(metallicRoughnessBuffer, width, height, mimeType).then((metallicRoughnessBase64) => {\r\n                    metallicRoughnessFactors.metallicRoughnessTextureBase64 = metallicRoughnessBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                const promise = this._createBase64FromCanvasAsync(baseColorBuffer, width, height, mimeType).then((baseColorBase64) => {\r\n                    metallicRoughnessFactors.baseColorTextureBase64 = baseColorBase64;\r\n                });\r\n                promises.push(promise);\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(\r\n            oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon)\r\n        );\r\n        const baseColorFromSpecular = specularGlossiness.specularColor\r\n            .subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic))\r\n            .scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const baseColor = babylonPBRMaterial._albedoColor;\r\n        const metallic = babylonPBRMaterial._metallic;\r\n        const roughness = babylonPBRMaterial._roughness;\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: roughness,\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonPBRMaterial._albedoTexture!, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(metallicTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getGLTFTextureSampler(texture: BaseTexture): ISampler {\r\n        const sampler = this._getGLTFTextureWrapModesSampler(texture);\r\n\r\n        const samplingMode = texture instanceof Texture ? texture.samplingMode : null;\r\n        if (samplingMode != null) {\r\n            switch (samplingMode) {\r\n                case Texture.LINEAR_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                    break;\r\n                }\r\n                case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.LINEAR;\r\n                    sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n                case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                    sampler.magFilter = TextureMagFilter.NEAREST;\r\n                    sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGLTFTextureWrapModesSampler(texture: BaseTexture): ISampler {\r\n        const wrapS = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapU : Texture.WRAP_ADDRESSMODE);\r\n        const wrapT = this._getGLTFTextureWrapMode(texture instanceof Texture ? texture.wrapV : Texture.WRAP_ADDRESSMODE);\r\n\r\n        if (wrapS === TextureWrapMode.REPEAT && wrapT === TextureWrapMode.REPEAT) {\r\n            // default wrapping mode in glTF, so omitting\r\n            return {};\r\n        }\r\n\r\n        return { wrapS: wrapS, wrapT: wrapT };\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const samplers = this._exporter._samplers;\r\n            const textures = this._exporter._textures;\r\n            const diffuseColor = babylonPBRMaterial._albedoColor;\r\n            const specularColor = babylonPBRMaterial._reflectivityColor;\r\n            const glossiness = babylonPBRMaterial._microSurface;\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: diffuseColor,\r\n                specularColor: specularColor,\r\n                glossiness: glossiness,\r\n            };\r\n            let samplerIndex: Nullable<number> = null;\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n            if (albedoTexture) {\r\n                const sampler = this._getGLTFTextureSampler(albedoTexture);\r\n                if (sampler.magFilter != null && sampler.minFilter != null && sampler.wrapS != null && sampler.wrapT != null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                }\r\n            }\r\n\r\n            const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n            if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((albedoTexture || reflectivityTexture) && hasTextureCoords) {\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    if (metallicRoughnessFactors.baseColorTextureBase64) {\r\n                        const glTFBaseColorTexture = this._getTextureInfoFromBase64(\r\n                            metallicRoughnessFactors.baseColorTextureBase64,\r\n                            \"bjsBaseColorTexture_\" + textures.length + \".png\",\r\n                            mimeType,\r\n                            albedoTexture ? albedoTexture.coordinatesIndex : null,\r\n                            samplerIndex\r\n                        );\r\n                        if (glTFBaseColorTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFBaseColorTexture;\r\n                        }\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureBase64) {\r\n                        const glTFMRColorTexture = this._getTextureInfoFromBase64(\r\n                            metallicRoughnessFactors.metallicRoughnessTextureBase64,\r\n                            \"bjsMetallicRoughnessTexture_\" + textures.length + \".png\",\r\n                            mimeType,\r\n                            reflectivityTexture ? reflectivityTexture.coordinatesIndex : null,\r\n                            samplerIndex\r\n                        );\r\n                        if (glTFMRColorTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFMRColorTexture;\r\n                        }\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            } else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Base Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Base Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        } else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _setMetallicRoughnessPbrMaterial(\r\n        metallicRoughness: Nullable<_IPBRMetallicRoughness>,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        mimeType: ImageMimeType,\r\n        hasTextureCoords: boolean\r\n    ): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial as PBRMaterial);\r\n            if (\r\n                !(\r\n                    _GLTFMaterialExporter._FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) &&\r\n                    babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon\r\n                )\r\n            ) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial._twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n                if (bumpTexture) {\r\n                    const promise = this._exportTextureAsync(bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n                if (ambientTexture) {\r\n                    const promise = this._exportTextureAsync(ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n                if (emissiveTexture) {\r\n                    const promise = this._exportTextureAsync(emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n            if (!_GLTFMaterialExporter._FuzzyEquals(emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private _getPixelsFromTexture(babylonTexture: BaseTexture): Promise<Nullable<Uint8Array | Float32Array>> {\r\n        const pixels =\r\n            babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT\r\n                ? (babylonTexture.readPixels() as Promise<Uint8Array>)\r\n                : (babylonTexture.readPixels() as Promise<Float32Array>);\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @return glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        return Promise.resolve().then(async () => {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            } else {\r\n                const pixels = await this._getPixelsFromTexture(babylonTexture);\r\n                if (!pixels) {\r\n                    return null;\r\n                }\r\n\r\n                const samplers = this._exporter._samplers;\r\n                const sampler = this._getGLTFTextureSampler(babylonTexture);\r\n                let samplerIndex: Nullable<number> = null;\r\n\r\n                //  if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n                let foundSamplerIndex: Nullable<number> = null;\r\n                for (let i = 0; i < samplers.length; ++i) {\r\n                    const s = samplers[i];\r\n                    if (s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT) {\r\n                        foundSamplerIndex = i;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (foundSamplerIndex == null) {\r\n                    samplers.push(sampler);\r\n                    samplerIndex = samplers.length - 1;\r\n                } else {\r\n                    samplerIndex = foundSamplerIndex;\r\n                }\r\n                const size = babylonTexture.getSize();\r\n\r\n                // Preserve texture mime type if defined\r\n                if ((babylonTexture as Texture).mimeType) {\r\n                    switch ((babylonTexture as Texture).mimeType) {\r\n                        case \"image/jpeg\":\r\n                            mimeType = ImageMimeType.JPEG;\r\n                            break;\r\n                        case \"image/png\":\r\n                            mimeType = ImageMimeType.PNG;\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                return this._createBase64FromCanvasAsync(pixels, size.width, size.height, mimeType).then((base64Data) => {\r\n                    const textureInfo = this._getTextureInfoFromBase64(\r\n                        base64Data,\r\n                        babylonTexture.name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\"),\r\n                        mimeType,\r\n                        babylonTexture.coordinatesIndex,\r\n                        samplerIndex\r\n                    );\r\n                    if (textureInfo) {\r\n                        this._textureMap[textureUid] = textureInfo;\r\n                        this._exporter._extensionsPostExportTextures(\"linkTextureInfo\", textureInfo, babylonTexture);\r\n                    }\r\n\r\n                    return textureInfo;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Builds a texture from base64 string\r\n     * @param base64Texture base64 texture string\r\n     * @param baseTextureName Name to use for the texture\r\n     * @param mimeType image mime type for the texture\r\n     * @param texCoordIndex\r\n     * @param samplerIndex\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    private _getTextureInfoFromBase64(\r\n        base64Texture: string,\r\n        baseTextureName: string,\r\n        mimeType: ImageMimeType,\r\n        texCoordIndex: Nullable<number>,\r\n        samplerIndex: Nullable<number>\r\n    ): Nullable<ITextureInfo> {\r\n        const textures = this._exporter._textures;\r\n        const images = this._exporter._images;\r\n        const imageData = this._exporter._imageData;\r\n        let textureInfo: Nullable<ITextureInfo> = null;\r\n\r\n        const glTFTexture: ITexture = {\r\n            source: images.length,\r\n            name: baseTextureName,\r\n        };\r\n        if (samplerIndex != null) {\r\n            glTFTexture.sampler = samplerIndex;\r\n        }\r\n\r\n        const binStr = atob(base64Texture.split(\",\")[1]);\r\n        const arrBuff = new ArrayBuffer(binStr.length);\r\n        const arr = new Uint8Array(arrBuff);\r\n        for (let i = 0, length = binStr.length; i < length; ++i) {\r\n            arr[i] = binStr.charCodeAt(i);\r\n        }\r\n        const imageValues = { data: arr, mimeType: mimeType };\r\n\r\n        const extension = mimeType === ImageMimeType.JPEG ? \".jpeg\" : \".png\";\r\n        let textureName = baseTextureName + extension;\r\n        const originalTextureName = textureName;\r\n        if (textureName in imageData) {\r\n            textureName = `${baseTextureName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[textureName] = imageValues;\r\n        if (mimeType === ImageMimeType.JPEG || mimeType === ImageMimeType.PNG) {\r\n            const glTFImage: IImage = {\r\n                name: baseTextureName,\r\n                uri: textureName,\r\n            };\r\n            let foundIndex: Nullable<number> = null;\r\n            for (let i = 0; i < images.length; ++i) {\r\n                if (images[i].uri === originalTextureName) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (foundIndex == null) {\r\n                images.push(glTFImage);\r\n                glTFTexture.source = images.length - 1;\r\n            } else {\r\n                glTFTexture.source = foundIndex;\r\n            }\r\n            textures.push(glTFTexture);\r\n            textureInfo = {\r\n                index: textures.length - 1,\r\n            };\r\n            if (texCoordIndex != null) {\r\n                textureInfo.texCoord = texCoordIndex;\r\n            }\r\n        } else {\r\n            Tools.Error(`Unsupported texture mime type ${mimeType}`);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n}\r\n"]}